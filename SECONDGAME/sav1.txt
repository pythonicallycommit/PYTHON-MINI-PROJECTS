import pygame

from settings import *



class Player(pygame.sprite.Sprite):

    def __init__(self, pos, groups, obstacle_sprites, create_attack, destroy_attack, create_magic, save_data):

        super().__init__(groups)

       

        # 1. Configuration de base de l'image (Transparence)

        self.image = pygame.Surface((48, 48), pygame.SRCALPHA)

        self.rect = self.image.get_rect(topleft=pos)

        self.hitbox = self.rect.inflate(-6, -26)



        # 2. STATS (Chargées depuis la sauvegarde)

        self.stats = save_data['stats']

        self.health = self.stats['health']

        self.energy = self.stats['magic']

        self.exp = save_data['exp']

        self.speed = self.stats['speed']

        self.rubies = save_data['rubies']

        self.sword_level = save_data['sword_level']



        # 3. ÉTAT ET MOUVEMENT (Définis AVANT le dessin pour éviter l'AttributeError)

        self.status = 'down'

        self.direction = pygame.math.Vector2()

        self.attacking = False

        self.attack_cooldown = 400

        self.attack_time = None

        self.obstacle_sprites = obstacle_sprites



        # 4. DESSIN INITIAL (Maintenant que status existe)

        self.draw_player_shape()



        # 5. MÉTHODES ET MAGIE

        self.create_attack = create_attack

        self.destroy_attack = destroy_attack

        self.create_magic = create_magic



        self.magic_index = 0

        self.magic_list = list(MAGIC_DATA.keys())

        self.can_cast = True

        self.magic_time = None

        self.magic_cooldown = 500



        # Invisibilité

        self.invisible = False



    def draw_player_shape(self):

        """Dessine un personnage humanoïde détaillé sans fichiers images."""

        self.image.fill((0, 0, 0, 0)) # Efface avec transparence totale

       

        # Couleurs

        CLOTHES = 'blue'

        SKIN = '#FFCC99'

        HAIR = '#663300'

       

        # 1. Corps (Torse)

        pygame.draw.rect(self.image, CLOTHES, (14, 20, 20, 22), border_radius=3)

       

        # 2. Tête

        pygame.draw.circle(self.image, SKIN, (24, 14), 10)

       

        # 3. Cheveux (Petit dôme)

        pygame.draw.arc(self.image, HAIR, (14, 4, 20, 15), 0, 3.14, 8)

       

        # 4. Yeux (Adaptés selon self.status)

        eye_y = 12

        if 'down' in self.status:

            pygame.draw.circle(self.image, 'black', (20, eye_y), 2)

            pygame.draw.circle(self.image, 'black', (28, eye_y), 2)

        elif 'up' in self.status:

            pass # Dos du personnage

        elif 'left' in self.status:

            pygame.draw.circle(self.image, 'black', (18, eye_y), 2)

        elif 'right' in self.status:

            pygame.draw.circle(self.image, 'black', (30, eye_y), 2)



        # 5. Bras (Animation statique simple)

        pygame.draw.rect(self.image, SKIN, (8, 22, 6, 12)) # Gauche

        pygame.draw.rect(self.image, SKIN, (34, 22, 6, 12)) # Droite



    def input(self):

        if not self.attacking:

            keys = pygame.key.get_pressed()



            # Déplacement

            if keys[pygame.K_UP]:

                self.direction.y = -1

                self.status = 'up'

            elif keys[pygame.K_DOWN]:

                self.direction.y = 1

                self.status = 'down'

            else:

                self.direction.y = 0



            if keys[pygame.K_RIGHT]:

                self.direction.x = 1

                self.status = 'right'

            elif keys[pygame.K_LEFT]:

                self.direction.x = -1

                self.status = 'left'

            else:

                self.direction.x = 0



            # Attaque Épée

            if keys[pygame.K_SPACE]:

                self.attacking = True

                self.attack_time = pygame.time.get_ticks()

                self.create_attack()



            # Attaque Magique

            if keys[pygame.K_LCTRL] and self.can_cast:

                self.attacking = True

                self.attack_time = pygame.time.get_ticks()

                style = self.magic_list[self.magic_index]

                strength = MAGIC_DATA[style]['strength'] + self.stats['attack']

                cost = MAGIC_DATA[style]['cost']

                self.create_magic(style, strength, cost)



    def move(self, speed):

        if self.direction.magnitude() != 0:

            self.direction = self.direction.normalize()



        self.hitbox.x += self.direction.x * speed

        self.collision('horizontal')

        self.hitbox.y += self.direction.y * speed

        self.collision('vertical')

        self.rect.center = self.hitbox.center



    def collision(self, direction):

        if direction == 'horizontal':

            for sprite in self.obstacle_sprites:

                if sprite.hitbox.colliderect(self.hitbox):

                    if self.direction.x > 0: self.hitbox.right = sprite.hitbox.left

                    if self.direction.x < 0: self.hitbox.left = sprite.hitbox.right



        if direction == 'vertical':

            for sprite in self.obstacle_sprites:

                if sprite.hitbox.colliderect(self.hitbox):

                    if self.direction.y > 0: self.hitbox.bottom = sprite.hitbox.top

                    if self.direction.y < 0: self.hitbox.top = sprite.hitbox.bottom



    def cooldowns(self):

        current_time = pygame.time.get_ticks()

        if self.attacking:

            if current_time - self.attack_time >= self.attack_cooldown:

                self.attacking = False

                self.destroy_attack()



    def energy_recovery(self):

        if self.energy < self.stats['magic']:

            self.energy += 0.05

        else:

            self.energy = self.stats['magic']



    def update(self):

        # L'ordre ici est important : on récupère l'input, on bouge, puis on redessine

        self.input()

        self.cooldowns()

        self.energy_recovery()

       

        # Effet d'invisibilité

        if self.invisible:

            self.image.set_alpha(100)

        else:

            self.image.set_alpha(255)

           

        # On redessine pour que le regard suive la direction

        self.draw_player_shape()

        self.move(self.speed)